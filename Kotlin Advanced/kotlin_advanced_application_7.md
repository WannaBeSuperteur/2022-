## 요구 사항 분석
워너비슈퍼추어소프트에서는 왓O, 넷O릭스와 같은 콘텐츠 플랫폼 서비스 앱인 "워너비콘"을 작년에 출시하여 현재 안드로이드 버전의 구글 플레이 누적 다운로드 수가 20만 건을 기록 중이다. 누적 다운로드 수의 증가 모멘텀을 더욱 키우고자, 워너비콘 기획팀은 인공지능을 이용하여 사용자에게 적절한 콘텐츠를 추천하는 기능을 기획하였다.

해당 기능을 제공하기 위해, 서버에서 각 콘텐츠를 ```6```차원의 벡터(즉, 숫자 값 ```6```개가 있는 배열, 예를 들어 ```[0.35, -0.17, 1.06, 0.42, 0.07, -0.24]```) 형태로 적절히 나타낸 것(이하 ```콘텐츠 벡터```)들을 클라이언트에 제공하면, 클라이언트에서는 다음과 같이 처리한다.
* 현재 사용자가 재미있게 보았다고 표시한 ```N```개의 콘텐츠의 콘텐츠 벡터들을 이들 각 콘텐츠의 가중치와 함께 서버로부터 받아온다.
* 이들 콘텐츠 벡터의 각 차원(```6```개의 각각의 숫자)의 값의 가중 평균을 이 가중치를 이용하여 구하여 콘텐츠 벡터와 동일한 형태로 나타낸다. 이것을 ```평균 콘텐츠 벡터```라고 한다.
* 평균 콘텐츠 벡터와 앱에서 서비스되는 모든 콘텐츠(상술한 ```N```개의 콘텐츠 제외)의 콘텐츠 벡터를 비교하여, 이들 모든 콘텐츠 중 평균 콘텐츠 벡터와의 거리 값이 가장 작은 ```10```개의 콘텐츠 정보를 거리 값이 가까운 순서대로 출력한다.
  * 이때 ```거리 값```은 두 콘텐츠 벡터의 대응되는 원소의 차이의 제곱의 합으로 정의한다.
  * 단, 사용자가 재미있다고 표시한 콘텐츠의 개수 ```N```의 값이 ```5``` 미만인 경우에는 거리 값이 가장 작은 ```5```개의 콘텐츠 정보를 거리 값이 가까운 순서대로 출력한다.

클라이언트에서 위와 같이 처리하도록 아래 데이터 클래스를 이용하여 프로그래밍하시오. (단, 앱에서 서비스되는 콘텐츠는 사용자가 재미있다고 표시한 ```N```개의 콘텐츠 외에 최소 10개가 있다.)

### 데이터 클래스
```kotlin
// 앱 사용자
data class User (
    val user_id: Long, // 사용자 ID
    val name: String, // 사용자 이름
    val fun_contents: List<FunContent> // 사용자가 재미있다고 표시한 콘텐츠(총 N개)
)

// 유저가 재미있다고 표시한 콘텐츠
data class FunContent (
    val weight: Double, // 가중치
    val content: Content // 해당 콘텐츠에 대한 정보
)

// 전체 콘텐츠 정보
data class AllContentsInfo (
    val vector_max: Double, // 벡터의 각 원소 값의 이론상 최댓값
    val vector_min: Double, // 벡터의 각 원소 값의 이론상 최댓값
    val all_contents: List<Content> // 전체 콘텐츠 정보
)

// 각 콘텐츠에 대한 정보
data class Content (
    val content_vector: List<Double>, // 콘텐츠 벡터 (6차원 배열)
    val user_fun: Boolean // 유저가 재미있다고 표시한 콘텐츠(총 N개)이면 true, 아니면 false
)
```
