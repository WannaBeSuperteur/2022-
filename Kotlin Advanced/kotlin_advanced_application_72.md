## 요구사항 분석
어떤 자연수 ```n```을 ```소수```, ```제곱수```, ```6의 배수```인 1 이상의 자연수의 합으로 나타낼 수 있는 모든 경우를 나타내는 함수 ```findCases(n)```을 작성하시오.

예를 들어 다음과 같다.
```kotlin
20 = 5 + 9 + 6
20 = 7 + 1 + 12
20 = 13 + 1 + 6
```

또한, 해당하는 각 경우의 합해지는 각 수들의 곱의 분포를 다음과 같이 나타내시오.
* 해당 분포의 최솟값과 최댓값을 기준으로 동일한 크기의 구간으로 전체 구간을 10등분한다.
* 각 구간에 속하는 곱의 값의 개수의 최댓값을 ```M```이라고 한다.
* 각 구간별로 속하는 값의 개수와 그 개수의 전체에 대한 비율을 출력하고, ```(해당 구간에 속하는 곱의 값의 개수) / M * 20``` (가장 가까운 정수로 내림) 만큼 특정 기호를 출력한다.

## 코드 및 실행 결과
### 코드
```kotlin
import kotlin.math.*

// 소수 판정
fun isPrime(n: Int): Boolean {
    if (n < 2) {
        return false
    }
    
    val sqrtN = sqrt(n.toDouble()).toInt()
    
    for (i in 2..sqrtN) {
        if (n % i == 0) {
            return false
        }
    }
    return true
}

// 소수 + 제곱수 + 6의 배수로 나타내기
fun findCases(n: Int) {
    
    // 소수인지를 직접 구하는 것보다는 각각의 (제곱수, 6의 배수) 에 대해 남은 수가 소수인지 판정하는 것이 빠름
    // 따라서 소수인지를 판정한 배열을 저장
    val primeTest = (0..n).map { if (isPrime(it)) "O" else "X" }
    
    println("1. prime test result :")
    for (i in 0 .. n / 20) {
        println(primeTest.subList(20 * i, Math.min(20 * (i + 1), primeTest.size)))
    }
    
    // 추가 순서는 제곱수가 최우선이지만 정렬 순서는 소수가 최우선이므로
    val resultList = mutableListOf<List<Int>>()
    
    // 각 제곱수 i * i에 대해서
    for (i in 1 .. n) {
        val iSquare = i * i
        if (iSquare > n) break
        
        // 0부터 n - i * i 까지의 각 6의 배수에 대해서
        for (j in 1 .. (n - iSquare) / 6) {
            val jMultiple = 6 * j
            
            val prime = n - (iSquare + jMultiple)
            if (primeTest[prime] == "O") {
                resultList.add(listOf(prime, iSquare, jMultiple))
            }
        }
    }
    
    // 정렬된 결과를 소수 > 제곱수 > 6의 배수 우선순위로 출력
    val resultListSorted = resultList.sortedWith(
        compareBy(
            { it[0] }, { it[1] }, { it[2] }
        )
    )
    
    print("\n")
    resultListSorted.forEach {
        println("${n} = ${it[0]} + ${it[1]} + ${it[2]}")
    }
    
    // 곱의 분포 출력
    val resultProduct = resultList.map {
        it.fold (1) { acc, e -> acc * e }
    }
    val productMax = resultProduct.max()
    val productMin = resultProduct.min()
    
    println("\n2. product of result :")
    for (i in 0 .. resultProduct.size / 10) {
        println(resultProduct.subList(10 * i, Math.min(10 * (i + 1), resultProduct.size)))
    }
    println("\n3. max = ${productMax}, min = ${productMin}")
    
    // 최댓값을 productMax보다 작게 해서 마지막 구간에 들어가게 하기 위해 productMax + 1을 사용
    val rangeCnt = 10
    
    val ranges = (0..rangeCnt).map {
        productMin + ((productMax + 1) - productMin) * it / rangeCnt
    }
    println("4. range = ${ranges}")
    
    val valueCount = (0 until rangeCnt).map { i ->
        resultProduct.count { it >= ranges[i] && it < ranges[i + 1] }
    }
    val valueCountMax = valueCount.max()
    println("5. value count = ${valueCount}\n6. value count max = ${valueCountMax}\n")
    
    // 각 구간별로 개수, 비율 및 기호 출력
    valueCount.forEachIndexed { idx, it ->
        val percent = round(it * 10000 / valueCount.sum().toDouble()) / 100
        val markCount = it * 20 / valueCountMax
        
        val startStr = String.format("%8d", ranges[idx])
        val endStr = String.format("%8d", ranges[idx + 1] - 1)
        val countStr = String.format("%4d", it)
        
        println("구간 ${startStr} ~ ${endStr}, 개수 : ${countStr}, 비율 : ${String.format("%6.2f", percent)}% / ${"#".repeat(markCount)}")
    }
}

fun main() {
    findCases(200)
}
```

### 실행 결과
```kotlin
1. prime test result :
[X, X, O, O, X, O, X, O, X, X, X, O, X, O, X, X, X, O, X, O]
[X, X, X, O, X, X, X, X, X, O, X, O, X, X, X, X, X, O, X, X]
[X, O, X, O, X, X, X, O, X, X, X, X, X, O, X, X, X, X, X, O]
[X, O, X, X, X, X, X, O, X, X, X, O, X, O, X, X, X, X, X, O]
[X, X, X, O, X, X, X, X, X, O, X, X, X, X, X, X, X, O, X, X]
[X, O, X, O, X, X, X, O, X, O, X, X, X, O, X, X, X, X, X, X]
[X, X, X, X, X, X, X, O, X, X, X, O, X, X, X, X, X, O, X, O]
[X, X, X, X, X, X, X, X, X, O, X, O, X, X, X, X, X, O, X, X]
[X, X, X, O, X, X, X, O, X, X, X, X, X, O, X, X, X, X, X, O]
[X, O, X, X, X, X, X, X, X, X, X, O, X, O, X, X, X, O, X, O]
[X]

200 = 2 + 36 + 162
200 = 2 + 144 + 54
200 = 5 + 9 + 186
200 = 5 + 81 + 114
200 = 7 + 1 + 192
200 = 7 + 25 + 168
200 = 7 + 49 + 144
200 = 7 + 121 + 72
200 = 7 + 169 + 24
200 = 11 + 9 + 180
200 = 11 + 81 + 108
200 = 13 + 1 + 186
200 = 13 + 25 + 162
200 = 13 + 49 + 138
200 = 13 + 121 + 66
200 = 13 + 169 + 18
200 = 17 + 9 + 174
200 = 17 + 81 + 102
200 = 19 + 1 + 180
200 = 19 + 25 + 156
200 = 19 + 49 + 132
200 = 19 + 121 + 60
200 = 19 + 169 + 12
200 = 23 + 9 + 168
200 = 23 + 81 + 96
200 = 29 + 9 + 162
200 = 29 + 81 + 90
200 = 31 + 1 + 168
200 = 31 + 25 + 144
200 = 31 + 49 + 120
200 = 31 + 121 + 48
200 = 37 + 1 + 162
200 = 37 + 25 + 138
200 = 37 + 49 + 114
200 = 37 + 121 + 42
200 = 41 + 9 + 150
200 = 41 + 81 + 78
200 = 43 + 1 + 156
200 = 43 + 25 + 132
200 = 43 + 49 + 108
200 = 43 + 121 + 36
200 = 47 + 9 + 144
200 = 47 + 81 + 72
200 = 53 + 9 + 138
200 = 53 + 81 + 66
200 = 59 + 9 + 132
200 = 59 + 81 + 60
200 = 61 + 1 + 138
200 = 61 + 25 + 114
200 = 61 + 49 + 90
200 = 61 + 121 + 18
200 = 67 + 1 + 132
200 = 67 + 25 + 108
200 = 67 + 49 + 84
200 = 67 + 121 + 12
200 = 71 + 9 + 120
200 = 71 + 81 + 48
200 = 73 + 1 + 126
200 = 73 + 25 + 102
200 = 73 + 49 + 78
200 = 73 + 121 + 6
200 = 79 + 1 + 120
200 = 79 + 25 + 96
200 = 79 + 49 + 72
200 = 83 + 9 + 108
200 = 83 + 81 + 36
200 = 89 + 9 + 102
200 = 89 + 81 + 30
200 = 97 + 1 + 102
200 = 97 + 25 + 78
200 = 97 + 49 + 54
200 = 101 + 9 + 90
200 = 101 + 81 + 18
200 = 103 + 1 + 96
200 = 103 + 25 + 72
200 = 103 + 49 + 48
200 = 107 + 9 + 84
200 = 107 + 81 + 12
200 = 109 + 1 + 90
200 = 109 + 25 + 66
200 = 109 + 49 + 42
200 = 113 + 9 + 78
200 = 113 + 81 + 6
200 = 127 + 1 + 72
200 = 127 + 25 + 48
200 = 127 + 49 + 24
200 = 131 + 9 + 60
200 = 137 + 9 + 54
200 = 139 + 1 + 60
200 = 139 + 25 + 36
200 = 139 + 49 + 12
200 = 149 + 9 + 42
200 = 151 + 1 + 48
200 = 151 + 25 + 24
200 = 157 + 1 + 42
200 = 157 + 25 + 18
200 = 163 + 1 + 36
200 = 163 + 25 + 12
200 = 167 + 9 + 24
200 = 173 + 9 + 18
200 = 179 + 9 + 12
200 = 181 + 1 + 18
200 = 193 + 1 + 6

2. product of result :
[1158, 3258, 5868, 6594, 7248, 8340, 9144, 9810, 9888, 9894]
[9480, 9198, 8844, 8418, 6708, 5994, 5208, 3420, 2418, 1344]
[19332, 28026, 36072, 56322, 66582, 70740, 79326, 80892, 81810, 81702]
[80676, 76680, 70092, 65826, 60912, 55350, 42282, 34776, 26622, 17820]
[8370, 48900, 70650, 90600, 125100, 152400, 179850, 185400, 189150, 189600]
[186150, 180900, 173850, 141900, 127650, 111600, 74100, 52650, 29400, 11664]
[81732, 149352, 224322, 242256, 256662, 278712, 279006, 275772, 269010, 227556]
[206682, 182280, 122892, 87906, 49392, 54918, 104004, 147258, 216270, 242028]
[276048, 286740, 283338, 274104, 259038, 211410, 178848, 140454, 96228, 46170]
[52998, 97284, 132858, 187308, 188034, 180048, 137940, 103818, 60984, 15552]
[38532, 39546, 28392]

3. max = 286740, min = 1158
4. range = [1158, 29716, 58274, 86832, 115391, 143949, 172507, 201066, 229624, 258182, 286741]
5. value count = [29, 13, 15, 7, 7, 3, 12, 5, 3, 9]
6. value count max = 29

구간     1158 ~    29715, 개수 :   29, 비율 :  28.16% / ####################
구간    29716 ~    58273, 개수 :   13, 비율 :  12.62% / ########
구간    58274 ~    86831, 개수 :   15, 비율 :  14.56% / ##########
구간    86832 ~   115390, 개수 :    7, 비율 :   6.80% / ####
구간   115391 ~   143948, 개수 :    7, 비율 :   6.80% / ####
구간   143949 ~   172506, 개수 :    3, 비율 :   2.91% / ##
구간   172507 ~   201065, 개수 :   12, 비율 :  11.65% / ########
구간   201066 ~   229623, 개수 :    5, 비율 :   4.85% / ###
구간   229624 ~   258181, 개수 :    3, 비율 :   2.91% / ##
구간   258182 ~   286740, 개수 :    9, 비율 :   8.74% / ######
```
